# =============================================================================
# PIPELINE CI/CD COM CODEQL - FATEC SANTANA DE PARNAIBAAAA
# =============================================================================
# Esta pipeline automatiza o processo de integraÃ§Ã£o e entrega contÃ­nua (CI/CD)
# para aplicaÃ§Ãµes Python, incluindo anÃ¡lise de seguranÃ§a com CodeQL.
#
# Fluxo:
# 1. AnÃ¡lise de SeguranÃ§a (CodeQL)
# 2. Testes Automatizados
# 3. Deploy para Ambiente de Stage
# =============================================================================

name: CI/CD Pipeline com CodeQL

# Define quando a pipeline serÃ¡ executada
on:
  # Executa quando hÃ¡ push na branch main
  push:
    branches: [ main ]
  
  # Executa quando hÃ¡ pull request para a branch main
  pull_request:
    branches: [ main ]
  
  # Permite execuÃ§Ã£o manual atravÃ©s do GitHub
  workflow_dispatch:

# Define as permissÃµes necessÃ¡rias para o workflow
permissions:
  contents: read           # Ler o cÃ³digo do repositÃ³rio
  security-events: write   # Escrever alertas de seguranÃ§a do CodeQL
  actions: read           # Ler status de actions

# =============================================================================
# JOBS: Cada job Ã© uma etapa independente da pipeline
# =============================================================================
jobs:

  # ---------------------------------------------------------------------------
  # JOB 1: ANÃLISE DE SEGURANÃ‡A COM CODEQL
  # ---------------------------------------------------------------------------
  # Este job analisa o cÃ³digo em busca de vulnerabilidades de seguranÃ§a
  # usando a ferramenta CodeQL do GitHub Advanced Security
  codeql-analysis:
    name: ğŸ”’ AnÃ¡lise de SeguranÃ§a (CodeQL)
    runs-on: ubuntu-latest
    
    steps:
      # PASSO 1: Baixa o cÃ³digo do repositÃ³rio
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4
        with:
          # Busca todo o histÃ³rico para anÃ¡lise mais precisa
          fetch-depth: 0

      # PASSO 2: Configura o ambiente Python
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'  # Cache das dependÃªncias para acelerar

      # PASSO 3: Instala as dependÃªncias do projeto
      - name: ğŸ“¦ Instalar dependÃªncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # PASSO 4: Inicializa o CodeQL para anÃ¡lise de seguranÃ§a
      - name: ğŸ”§ Inicializar CodeQL
        uses: github/codeql-action/init@v3
        with:
          # Define que vamos analisar cÃ³digo Python
          languages: python
          
          # Arquivo de configuraÃ§Ã£o personalizada (opcional)
          config-file: ./.github/codeql-config.yml
          
          # Queries adicionais de seguranÃ§a (recomendado para produÃ§Ã£o)
          queries: security-extended,security-and-quality

      # PASSO 5: CodeQL faz a anÃ¡lise automÃ¡tica do cÃ³digo Python
      # NÃ£o precisa de build pois Python Ã© interpretado
      - name: ğŸ” AnÃ¡lise AutomÃ¡tica do CÃ³digo
        uses: github/codeql-action/autobuild@v3

      # PASSO 6: Executa a anÃ¡lise e envia resultados
      - name: ğŸ“Š Executar AnÃ¡lise CodeQL
        id: codeql-analyze
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python"
          upload: true
          
      # PASSO 7: Aguarda processamento dos resultados
      - name: â³ Aguardar processamento do CodeQL
        run: |
          echo "â³ Aguardando o GitHub processar os resultados do CodeQL (polling)..."
          # Poll na API por atÃ© 5 minutos (300s) a cada 10s para ver se alertas foram gerados
          GH_TOKEN=${{ github.token }}
          REPO=${{ github.repository }}
          REF=${{ github.ref }}
          TIMEOUT=300
          INTERVAL=10
          ELAPSED=0
          ALERT_COUNT=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            ALERTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${REPO}/code-scanning/alerts?state=open&ref=${REF}")

            ALERT_COUNT=$(echo "$ALERTS" | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ALERT_COUNT" -gt 0 ]; then
              echo "ğŸ“Š Total de alertas abertos: $ALERT_COUNT"
              break
            fi

            echo "â³ Nenhum alerta ainda. Aguardando ${INTERVAL}s (total aguardado: ${ELAPSED}s)..."
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "ğŸ“Š Total de alertas abertos: $ALERT_COUNT"
          
      # PASSO 8: Verifica alertas de seguranÃ§a via API do GitHub
      - name: ğŸš« Bloquear se houver vulnerabilidades
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ğŸ” Verificando alertas de Code Scanning (resultado do polling anterior)..."

          # Caso o polling anterior jÃ¡ tenha identificado alertas, vamos usar essa info
          # Tentar obter alertas novamente para garantir consistÃªncia
          ALERTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?state=open&ref=${{ github.ref }}")

          ALERT_COUNT=$(echo "$ALERTS" | jq '. | length' 2>/dev/null || echo "0")

          echo "ğŸ“Š Total de alertas abertos: $ALERT_COUNT"

          if [ "$ALERT_COUNT" -gt 0 ]; then
            echo ""
            echo "âŒ ============================================"
            echo "âŒ PIPELINE BLOQUEADA POR VULNERABILIDADES"
            echo "âŒ ============================================"
            echo "ğŸ”’ Foram encontradas $ALERT_COUNT vulnerabilidade(s) de seguranÃ§a!"
            echo ""
            echo "ğŸ“‹ Detalhes dos alertas:"
            echo "$ALERTS" | jq -r '.[] | "  â€¢ [\(.rule.severity | ascii_upcase)] \(.rule.description) em \(.most_recent_instance.location.path):\(.most_recent_instance.location.start_line)"' 2>/dev/null || echo "$ALERTS" | jq -r '.[] | "  â€¢ \(.rule.description)"'
            echo ""
            echo "ğŸ”— Veja mais em: https://github.com/${{ github.repository }}/security/code-scanning"
            echo "âŒ ============================================"
            echo ""
            exit 1
          else
            echo "âœ… Nenhuma vulnerabilidade encontrada pelo CodeQL (apÃ³s aguardar)."
          fi

          echo "ğŸ” Agora executando Bandit para checagem adicional de Python..."
          pip install bandit jq || true
          bandit -r . -f json -o bandit-report.json || true
          BANDIT_COUNT=$(jq '.results | length' bandit-report.json 2>/dev/null || echo "0")
          echo "ğŸ“Š Bandit encontrou $BANDIT_COUNT problema(s)"
          if [ "$BANDIT_COUNT" -gt 0 ]; then
            echo "âŒ Bandit detectou problemas de seguranÃ§a. Falhando a pipeline." 
            jq -r '.results[] | "  â€¢ [Severity: \(.issue_severity)] \(.issue_text) em \(.filename):\(.line_number)"' bandit-report.json || cat bandit-report.json
            exit 1
          else
            echo "âœ… Bandit nÃ£o encontrou problemas crÃ­ticos."
          fi
          
      - name: âœ… AnÃ¡lise de SeguranÃ§a Aprovada
        if: success()
        run: |
          echo "âœ… CÃ³digo aprovado na anÃ¡lise de seguranÃ§a!"
          echo "ğŸ‰ Todas as verificaÃ§Ãµes de seguranÃ§a passaram!"

  # ---------------------------------------------------------------------------
  # JOB 2: TESTES AUTOMATIZADOS
  # ---------------------------------------------------------------------------
  # Executa testes unitÃ¡rios e de integraÃ§Ã£o
  # Depende do job CodeQL - sÃ³ executa se a anÃ¡lise passar
  tests:
    name: ğŸ§ª Testes Automatizados
    runs-on: ubuntu-latest
    # IMPORTANTE: Este job sÃ³ executa se o CodeQL passar
    needs: codeql-analysis
    
    steps:
      # PASSO 1: Baixa o cÃ³digo
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4

      # PASSO 2: Configura Python
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      # PASSO 3: Instala dependÃªncias incluindo ferramentas de teste
      - name: ğŸ“¦ Instalar dependÃªncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      # PASSO 4: Executa os testes com cobertura
      - name: ğŸ§ª Executar testes
        run: |
          echo "ğŸ§ª Executando testes..."
          # Exemplo: pytest tests/ --cov=. --cov-report=term
          python -m pytest --version || echo "âš ï¸ Adicione testes ao projeto!"
          echo "âœ… Testes concluÃ­dos!"

      # PASSO 5: Valida sintaxe e estilo do cÃ³digo
      - name: ğŸ¨ Validar qualidade do cÃ³digo
        run: |
          pip install flake8
          echo "ğŸ” Verificando qualidade do cÃ³digo..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          echo "âœ… CÃ³digo validado!"

  # ---------------------------------------------------------------------------
  # JOB 3: DEPLOY PARA STAGE
  # ---------------------------------------------------------------------------
  # Realiza o deploy para o ambiente de homologaÃ§Ã£o/stage
  # SÃ³ executa se CodeQL e testes passarem
  deploy-stage:
    name: ğŸš€ Deploy para Stage
    runs-on: ubuntu-latest
    # IMPORTANTE: SÃ³ executa se CodeQL e testes passarem
    needs: [codeql-analysis, tests]
    
    # Define o ambiente GitHub (aparece na UI)
    environment:
      name: stage
      url: https://stage.exemplo.com
    
    steps:
      # PASSO 1: Baixa o cÃ³digo
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4

      # PASSO 2: Configura Python
      - name: ğŸ Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # PASSO 3: Prepara artefatos para deploy
      - name: ğŸ“¦ Preparar artefatos
        run: |
          echo "ğŸ“¦ Criando pacote para deploy..."
          pip install -r requirements.txt
          echo "âœ… Artefatos preparados!"

      # PASSO 4: Simula deploy (substitua com seu processo real)
      - name: ğŸš€ Deploy para Stage
        run: |
          echo "ğŸš€ Iniciando deploy para ambiente de STAGE..."
          echo "ğŸ“ Ambiente: Stage"
          echo "ğŸ“¦ VersÃ£o: ${{ github.sha }}"
          echo "ğŸ‘¤ Autor: ${{ github.actor }}"
          echo ""
          echo "âœ… Deploy realizado com sucesso!"
          echo "ğŸŒ AplicaÃ§Ã£o disponÃ­vel em: https://stage.exemplo.com"
        
      # PASSO 5: Notifica sucesso
      - name: âœ… Notificar conclusÃ£o
        if: success()
        run: |
          echo "============================================"
          echo "âœ… PIPELINE CONCLUÃDA COM SUCESSO!"
          echo "============================================"
          echo "ğŸ”’ SeguranÃ§a: Aprovado pelo CodeQL"
          echo "ğŸ§ª Testes: Todos passaram"
          echo "ğŸš€ Deploy: Realizado em Stage"
          echo "============================================"

      # PASSO 6: Notifica falha
      - name: âŒ Notificar falha
        if: failure()
        run: |
          echo "============================================"
          echo "âŒ PIPELINE FALHOU!"
          echo "============================================"
          echo "Verifique os logs acima para detalhes"
          echo "============================================"
