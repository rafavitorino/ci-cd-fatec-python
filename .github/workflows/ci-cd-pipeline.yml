# =============================================================================
# PIPELINE CI/CD COM CODEQL - FATEC SANTANA DE PARNAIBAAAA
# =============================================================================
# Esta pipeline automatiza o processo de integra√ß√£o e entrega cont√≠nua (CI/CD)
# para aplica√ß√µes Python, incluindo an√°lise de seguran√ßa com CodeQL.
#
# Fluxo:
# 1. An√°lise de Seguran√ßa (CodeQL)
# 2. Testes Automatizados
# 3. Deploy para Ambiente de Stage
# =============================================================================

name: CI/CD Pipeline com CodeQL

# Define quando a pipeline ser√° executada
on:
  # Executa quando h√° push na branch main
  push:
    branches: [ main ]
  
  # Executa quando h√° pull request para a branch main
  pull_request:
    branches: [ main ]
  
  # Permite execu√ß√£o manual atrav√©s do GitHub
  workflow_dispatch:

# Define as permiss√µes necess√°rias para o workflow
permissions:
  contents: read           # Ler o c√≥digo do reposit√≥rio
  security-events: write   # Escrever alertas de seguran√ßa do CodeQL
  actions: read           # Ler status de actions

# =============================================================================
# JOBS: Cada job √© uma etapa independente da pipeline
# =============================================================================
jobs:

  # ---------------------------------------------------------------------------
  # JOB 1: AN√ÅLISE DE SEGURAN√áA COM CODEQL
  # ---------------------------------------------------------------------------
  # Este job analisa o c√≥digo em busca de vulnerabilidades de seguran√ßa
  # usando a ferramenta CodeQL do GitHub Advanced Security
  codeql-analysis:
    name: üîí An√°lise de Seguran√ßa (CodeQL)
    runs-on: ubuntu-latest
    
    steps:
      # PASSO 1: Baixa o c√≥digo do reposit√≥rio
      - name: üì• Checkout do c√≥digo
        uses: actions/checkout@v4
        with:
          # Busca todo o hist√≥rico para an√°lise mais precisa
          fetch-depth: 0

      # PASSO 2: Configura o ambiente Python
      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'  # Cache das depend√™ncias para acelerar

      # PASSO 3: Instala as depend√™ncias do projeto
      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # PASSO 4: Inicializa o CodeQL para an√°lise de seguran√ßa
      - name: üîß Inicializar CodeQL
        uses: github/codeql-action/init@v3
        with:
          # Define que vamos analisar c√≥digo Python
          languages: python
          
          # Arquivo de configura√ß√£o personalizada (opcional)
          config-file: ./.github/codeql-config.yml
          
          # Queries adicionais de seguran√ßa (recomendado para produ√ß√£o)
          queries: security-extended,security-and-quality

      # PASSO 5: CodeQL faz a an√°lise autom√°tica do c√≥digo Python
      # N√£o precisa de build pois Python √© interpretado
      - name: üîç An√°lise Autom√°tica do C√≥digo
        uses: github/codeql-action/autobuild@v3

      # PASSO 6: Executa a an√°lise e envia resultados
      - name: üìä Executar An√°lise CodeQL
        id: codeql-analyze
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python"
          upload: true
          
      # PASSO 7: Aguarda processamento dos resultados
      - name: ‚è≥ Aguardar processamento do CodeQL
        run: |
          echo "‚è≥ Aguardando o GitHub processar os resultados do CodeQL (polling)..."
          # Poll na API por at√© 5 minutos (300s) a cada 10s para ver se alertas foram gerados
          GH_TOKEN=${{ github.token }}
          REPO=${{ github.repository }}
          REF=${{ github.ref }}
          TIMEOUT=300
          INTERVAL=10
          ELAPSED=0
          ALERT_COUNT=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            ALERTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${REPO}/code-scanning/alerts?state=open&ref=${REF}")

            ALERT_COUNT=$(echo "$ALERTS" | jq '. | length' 2>/dev/null || echo "0")

            if [ "$ALERT_COUNT" -gt 0 ]; then
              echo "üìä Total de alertas abertos: $ALERT_COUNT"
              break
            fi

            echo "‚è≥ Nenhum alerta ainda. Aguardando ${INTERVAL}s (total aguardado: ${ELAPSED}s)..."
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "üìä Total de alertas abertos: $ALERT_COUNT"
          
      # PASSO 8: Verifica alertas de seguran√ßa via API do GitHub
      - name: üö´ Bloquear se houver vulnerabilidades
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üîç Verificando alertas de Code Scanning (resultado do polling anterior)..."

          # Caso o polling anterior j√° tenha identificado alertas, vamos usar essa info
          # Tentar obter alertas novamente para garantir consist√™ncia
          ALERTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?state=open&ref=${{ github.ref }}")

          ALERT_COUNT=$(echo "$ALERTS" | jq '. | length' 2>/dev/null || echo "0")

          echo "üìä Total de alertas abertos: $ALERT_COUNT"

          if [ "$ALERT_COUNT" -gt 0 ]; then
            echo ""
            echo "‚ùå ============================================"
            echo "‚ùå PIPELINE BLOQUEADA POR VULNERABILIDADES"
            echo "‚ùå ============================================"
            echo "üîí Foram encontradas $ALERT_COUNT vulnerabilidade(s) de seguran√ßa!"
            echo ""
            echo "üìã Detalhes dos alertas:"
            echo "$ALERTS" | jq -r '.[] | "  ‚Ä¢ [\(.rule.severity | ascii_upcase)] \(.rule.description) em \(.most_recent_instance.location.path):\(.most_recent_instance.location.start_line)"' 2>/dev/null || echo "$ALERTS" | jq -r '.[] | "  ‚Ä¢ \(.rule.description)"'
            echo ""
            echo "üîó Veja mais em: https://github.com/${{ github.repository }}/security/code-scanning"
            echo "‚ùå ============================================"
            echo ""
            exit 1
          else
            echo "‚úÖ Nenhuma vulnerabilidade encontrada pelo CodeQL (ap√≥s aguardar)."
          fi

          echo "üîé Agora executando Bandit para checagem adicional de Python..."
          pip install bandit
          
          # Executa Bandit E FALHA se houver erro ou problema encontrado
          bandit -r . -f json -o bandit-report.json
          BANDIT_EXIT_CODE=$?
          
          if [ $BANDIT_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  Bandit retornou c√≥digo de erro (pode ter encontrado problemas)"
          fi
          
          BANDIT_COUNT=$(jq '.results | length' bandit-report.json 2>/dev/null || echo "0")
          echo "üìä Bandit encontrou $BANDIT_COUNT problema(s)"
          
          if [ "$BANDIT_COUNT" -gt 0 ]; then
            echo ""
            echo "‚ùå ============================================"
            echo "‚ùå BANDIT DETECTOU PROBLEMAS DE SEGURAN√áA!"
            echo "‚ùå ============================================"
            jq -r '.results[] | "  ‚Ä¢ [Severity: \(.issue_severity)] \(.issue_text) em \(.filename):\(.line_number)"' bandit-report.json
            echo "‚ùå ============================================"
            exit 1
          fi
          
          # Script Python adicional: detectar padr√µes vulner√°veis conhecidos
          echo ""
          echo "üîé Executando an√°lise de padr√µes vulner√°veis customizados..."
          python << 'PYTHON_SCRIPT'
import os
import re
import sys

VULNERABLE_PATTERNS = [
    (r"os\.system\s*\(", "os.system com comando dinamicamente constru√≠do", "COMMAND_INJECTION"),
    (r"subprocess\.(Popen|call|run)\s*\([^[]*[+\"]", "subprocess sem lista de argumentos", "COMMAND_INJECTION"),
    (r"cursor\.execute\s*\(\s*f[\'\"]", "cursor.execute com f-string", "SQL_INJECTION"),
    (r"cursor\.execute\s*\([^)]*[+%][^)]*\)", "cursor.execute com concatena√ß√£o", "SQL_INJECTION"),
    (r"open\s*\(\s*f[\'\"]", "open com f-string (path traversal)", "PATH_TRAVERSAL"),
    (r"open\s*\([^)]*\+[^)]*\)", "open com concatena√ß√£o de caminho", "PATH_TRAVERSAL"),
    (r"PASSWORD\s*=\s*[\'\"][^\'\"]*[\'\"]", "senha hardcoded", "HARD_CODED_CREDENTIALS"),
    (r"API_KEY\s*=\s*[\'\"][^\'\"]*[\'\"]", "API key hardcoded", "HARD_CODED_CREDENTIALS"),
    (r"SECRET\s*=\s*[\'\"][^\'\"]*[\'\"]", "secret hardcoded", "HARD_CODED_CREDENTIALS"),
    (r"pickle\.loads\(", "pickle.loads com dados n√£o confi√°veis", "INSECURE_DESERIALIZATION"),
    (r"random\.(randint|choice|random)\s*\(", "random para criptografia", "WEAK_RANDOMNESS"),
    (r"hashlib\.(md5|sha1)\(", "MD5 ou SHA1 para senha", "WEAK_CRYPTOGRAPHY"),
]

found_issues = []
ignored_dirs = {'.git', '__pycache__', 'venv', 'env', '.venv', '.env', 'node_modules', '.pytest_cache'}

for root, dirs, files in os.walk('.'):
    # Remover diret√≥rios ignorados
    dirs[:] = [d for d in dirs if d not in ignored_dirs]
    
    for file in files:
        if file.endswith('.py'):
            filepath = os.path.join(root, file)
            try:
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                for pattern, description, vuln_type in VULNERABLE_PATTERNS:
                    if re.search(pattern, content, re.MULTILINE | re.IGNORECASE):
                        found_issues.append({
                            'file': filepath,
                            'description': description,
                            'type': vuln_type
                        })
                        break  # Evitar duplicatas no mesmo arquivo
            except Exception as e:
                pass

if found_issues:
    print("")
    print("‚ùå ============================================")
    print("‚ùå PROBLEMAS DE SEGURAN√áA ENCONTRADOS!")
    print("‚ùå ============================================")
    for issue in found_issues:
        print(f"  ‚Ä¢ [{issue['type']}] {issue['description']} em {issue['file']}")
    print("‚ùå ============================================")
    sys.exit(1)
else:
    print("‚úÖ Nenhum padr√£o vulner√°vel detectado na an√°lise customizada.")
PYTHON_SCRIPT
          
          echo ""
          echo "‚úÖ Todas as verifica√ß√µes de seguran√ßa passaram!"
          
      - name: ‚úÖ An√°lise de Seguran√ßa Aprovada
        if: success()
        run: |
          echo "‚úÖ C√≥digo aprovado na an√°lise de seguran√ßa!"
          echo "üéâ Todas as verifica√ß√µes de seguran√ßa passaram!"

  # ---------------------------------------------------------------------------
  # JOB 2: TESTES AUTOMATIZADOS
  # ---------------------------------------------------------------------------
  # Executa testes unit√°rios e de integra√ß√£o
  # Depende do job CodeQL - s√≥ executa se a an√°lise passar
  tests:
    name: üß™ Testes Automatizados
    runs-on: ubuntu-latest
    # IMPORTANTE: Este job s√≥ executa se o CodeQL passar
    needs: codeql-analysis
    
    steps:
      # PASSO 1: Baixa o c√≥digo
      - name: üì• Checkout do c√≥digo
        uses: actions/checkout@v4

      # PASSO 2: Configura Python
      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      # PASSO 3: Instala depend√™ncias incluindo ferramentas de teste
      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      # PASSO 4: Executa os testes com cobertura
      - name: üß™ Executar testes
        run: |
          echo "üß™ Executando testes..."
          # Exemplo: pytest tests/ --cov=. --cov-report=term
          python -m pytest --version || echo "‚ö†Ô∏è Adicione testes ao projeto!"
          echo "‚úÖ Testes conclu√≠dos!"

      # PASSO 5: Valida sintaxe e estilo do c√≥digo
      - name: üé® Validar qualidade do c√≥digo
        run: |
          pip install flake8
          echo "üîç Verificando qualidade do c√≥digo..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          echo "‚úÖ C√≥digo validado!"

  # ---------------------------------------------------------------------------
  # JOB 3: DEPLOY PARA STAGE
  # ---------------------------------------------------------------------------
  # Realiza o deploy para o ambiente de homologa√ß√£o/stage
  # S√≥ executa se CodeQL e testes passarem
  deploy-stage:
    name: üöÄ Deploy para Stage
    runs-on: ubuntu-latest
    # IMPORTANTE: S√≥ executa se CodeQL e testes passarem
    needs: [codeql-analysis, tests]
    
    # Define o ambiente GitHub (aparece na UI)
    environment:
      name: stage
      url: https://stage.exemplo.com
    
    steps:
      # PASSO 1: Baixa o c√≥digo
      - name: üì• Checkout do c√≥digo
        uses: actions/checkout@v4

      # PASSO 2: Configura Python
      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # PASSO 3: Prepara artefatos para deploy
      - name: üì¶ Preparar artefatos
        run: |
          echo "üì¶ Criando pacote para deploy..."
          pip install -r requirements.txt
          echo "‚úÖ Artefatos preparados!"

      # PASSO 4: Simula deploy (substitua com seu processo real)
      - name: üöÄ Deploy para Stage
        run: |
          echo "üöÄ Iniciando deploy para ambiente de STAGE..."
          echo "üìç Ambiente: Stage"
          echo "üì¶ Vers√£o: ${{ github.sha }}"
          echo "üë§ Autor: ${{ github.actor }}"
          echo ""
          echo "‚úÖ Deploy realizado com sucesso!"
          echo "üåê Aplica√ß√£o dispon√≠vel em: https://stage.exemplo.com"
        
      # PASSO 5: Notifica sucesso
      - name: ‚úÖ Notificar conclus√£o
        if: success()
        run: |
          echo "============================================"
          echo "‚úÖ PIPELINE CONCLU√çDA COM SUCESSO!"
          echo "============================================"
          echo "üîí Seguran√ßa: Aprovado pelo CodeQL"
          echo "üß™ Testes: Todos passaram"
          echo "üöÄ Deploy: Realizado em Stage"
          echo "============================================"

      # PASSO 6: Notifica falha
      - name: ‚ùå Notificar falha
        if: failure()
        run: |
          echo "============================================"
          echo "‚ùå PIPELINE FALHOU!"
          echo "============================================"
          echo "Verifique os logs acima para detalhes"
          echo "============================================"
